################################################################################
# Copyright (c) 2024, National Research Foundation (SARAO)
#
# Licensed under the BSD 3-Clause License (the "License"); you may not use
# this file except in compliance with the License. You may obtain a copy
# of the License at
#
#   https://opensource.org/licenses/BSD-3-Clause
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

"""Utilities for unit tests."""

from collections.abc import Callable, Iterable, Iterator
from fractions import Fraction
from typing import Generic, TypeVar

import numpy as np
import xarray as xr
from astropy.time import Time

from katcbf_vlbi_resample.utils import is_cupy, isel_time

_T_co = TypeVar("_T_co", covariant=True)


def complex_random(gen_real: Callable[[], np.ndarray], /) -> np.ndarray:
    """Generate complex random numbers from a callback for real random numbers.

    The resulting random numbers have the real and imaginary parts independently
    generated by the callable.
    """
    return gen_real() + 1j * gen_real()


class SimpleStream(Generic[_T_co]):
    """Stream that holds its data in memory."""

    def __init__(
        self, time_base: Time, time_scale: Fraction, channels: int | None, is_cupy: bool, chunks: Iterable[_T_co]
    ) -> None:
        self.time_base = time_base
        self.time_scale = time_scale
        self.channels = channels
        self.is_cupy = is_cupy
        self.chunks = chunks

    def __iter__(self) -> Iterator[_T_co]:
        return iter(self.chunks)

    @staticmethod
    def factory(
        time_base: Time, time_scale: Fraction, data: xr.DataArray, chunk_size: int | Iterable[int] | None = None
    ) -> "SimpleStream[xr.DataArray]":
        """Build a :class:`SimpleStream` by splitting data into chunks.

        This can only generate a stream of data arrays, not data sets.

        If `chunk_size` is given, the given `data` will be split into chunks of this
        size (on the time dimension). If it is a sequence, it specifies the chunk
        sizes to use (which must sum to ``data.sizes("time")``).
        """
        if chunk_size is None:
            chunks = [data]
        elif isinstance(chunk_size, int):
            chunks = []
            for start in range(0, data.sizes["time"], chunk_size):
                stop = min(start + chunk_size, data.sizes["time"])
                chunk = isel_time(data, np.s_[start:stop])
                chunks.append(chunk)
        else:
            chunks = []
            for size in chunk_size:
                assert size <= data.sizes["time"]
                chunks.append(isel_time(data, np.s_[:size]))
                data = isel_time(data, np.s_[size:])
            assert data.sizes["time"] == 0, "chunk_size does not sum to the data size"

        return SimpleStream(
            time_base=time_base,
            time_scale=time_scale,
            channels=data.sizes.get("channel"),
            is_cupy=is_cupy(data),
            chunks=chunks,
        )
